{"version":3,"sources":["../../src/utilities/writeIndexCli.js"],"names":["directoryPaths","options","sortedDirectoryPaths","updateIndex","chalk","green","red","recursive","ignoreUnsafe","extensions","_","map","dir","fileName","silent","flatten","uniq","reverse","join","filter","directoryPath","forEach","existingIndexCode","config","siblings","ignoreDirectories","indexCode","banner","indexFilePath","path","resolve","fs","readFileSync","error","writeFileSync","yellow"],"mappings":"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","file":"writeIndexCli.js","sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport _ from 'lodash';\nimport chalk from 'chalk';\nimport createIndexCode from './createIndexCode';\nimport validateTargetDirectory from './validateTargetDirectory';\nimport readDirectory from './readDirectory';\nimport readIndexConfig from './readIndexConfig';\nimport sortByDepth from './sortByDepth';\nimport log from './log';\nimport findIndexFiles from './findIndexFiles';\n\nexport default (directoryPaths, options = {}) => {\n  let sortedDirectoryPaths;\n\n  sortedDirectoryPaths = sortByDepth(directoryPaths);\n\n  log('Target directories', sortedDirectoryPaths);\n  if (options.updateIndex) {\n    log('Update index:', options.updateIndex ? chalk.green('true') : chalk.red('false'));\n  } else {\n    log('Recursive:', options.recursive ? chalk.green('true') : chalk.red('false'));\n    log('Ignore unsafe:', options.ignoreUnsafe ? chalk.green('true') : chalk.red('false'));\n    log('Extensions:', chalk.green(options.extensions));\n  }\n\n  if (options.updateIndex || options.recursive) {\n    sortedDirectoryPaths = _.map(sortedDirectoryPaths, (dir) => {\n      return findIndexFiles(dir, {\n        fileName: options.updateIndex ? 'index.js' : '*',\n        silent: options.updateIndex || options.ignoreUnsafe\n      });\n    });\n    sortedDirectoryPaths = _.flatten(sortedDirectoryPaths);\n    sortedDirectoryPaths = _.uniq(sortedDirectoryPaths);\n    sortedDirectoryPaths = sortByDepth(sortedDirectoryPaths);\n\n    log('Updating index files in:', sortedDirectoryPaths.reverse().join(', '));\n  }\n\n  sortedDirectoryPaths = sortedDirectoryPaths.filter((directoryPath) => {\n    return validateTargetDirectory(directoryPath, {silent: options.ignoreUnsafe});\n  });\n\n  _.forEach(sortedDirectoryPaths, (directoryPath) => {\n    let existingIndexCode;\n\n    const config = readIndexConfig(directoryPath);\n\n    const siblings = readDirectory(directoryPath, {\n      config,\n      extensions: options.extensions,\n      ignoreDirectories: options.ignoreDirectories,\n      silent: options.ignoreUnsafe\n    });\n\n    const indexCode = createIndexCode(siblings, {\n      banner: options.banner,\n      config\n    });\n\n    const indexFilePath = path.resolve(directoryPath, 'index.js');\n\n    try {\n      existingIndexCode = fs.readFileSync(indexFilePath, 'utf8');\n\n        /* eslint-disable no-empty */\n    } catch (error) {\n\n    }\n\n        /* eslint-enable no-empty */\n\n    fs.writeFileSync(indexFilePath, indexCode);\n\n    if (existingIndexCode && existingIndexCode === indexCode) {\n      log(indexFilePath, chalk.yellow('[index has not changed]'));\n    } else if (existingIndexCode && existingIndexCode !== indexCode) {\n      log(indexFilePath, chalk.green('[updated index]'));\n    } else {\n      log(indexFilePath, chalk.green('[created index]'));\n    }\n  });\n\n  log('Done');\n};\n"]}